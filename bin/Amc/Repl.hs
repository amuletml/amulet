{-# LANGUAGE OverloadedStrings, FlexibleContexts, ScopedTypeVariables, ViewPatterns, TypeFamilies, MultiWayIf, TemplateHaskell #-}
{-# OPTIONS_GHC -Wno-orphans #-}

module Amc.Repl
  ( repl
  , replFrom
  , runRemoteReplCommand
  ) where

import Control.Monad.State.Strict
import Control.Exception

import qualified Data.Text.Encoding as T
import qualified Data.Text.Lazy as L
import qualified Data.Text.IO as T
import qualified Data.Text as T

import qualified Data.ByteString as Bs
import qualified Data.VarMap as VarMap

import Data.Traversable
import Data.Bifunctor
import Data.Foldable
import Data.Position
import Data.Spanned
import Data.Triple
import Data.Maybe
import Data.Char

import qualified Foreign.Lua.Core.Types as L
import qualified Foreign.Lua as L

import System.Console.Haskeline hiding (display, bracket, throwTo)
import System.Environment
import System.Directory
import System.IO

import qualified Syntax.Builtin as Bi
import Syntax.Resolve (ResolveResult(..), resolveProgram)
import Syntax.Resolve.Scope (Signature)
import Syntax.Resolve.Import (runNullImport)
import Syntax (displayType)
import qualified Syntax.Var as S
import qualified Syntax as S

import qualified Control.Monad.Infer as T
import Control.Monad.Namey

import Parser.Wrapper (Parser, runParser)
import Parser.Token
import Parser.Error
import Parser

import qualified Core.Lower as L
import qualified Core.Core as C
import Core.Occurrence
import Core.Core (Stmt)
import Core.Simplify
import Core.Var

import qualified Frontend.Driver as D
import Frontend.Errors

import Control.Lens

import qualified Backend.Lua.Postprocess as B
import qualified Backend.Lua.Emit as B
import qualified Backend.Escape as B
import Language.Lua.Syntax

import Text.Pretty.Semantic

import qualified Network.Socket as Net

import Control.Concurrent

import Amc.Repl.Display
import Amc.Debug
import Version

-- Aghh MonadFail!
instance MonadFail L.Lua where
  fail x = error $ "MonadFail L.Lua: fail " ++ x

data ReplState = ReplState
  { resolveScope :: Signature
  , inferScope   :: T.Env
  , emitState    :: B.TopEmitState
  , lastName     :: S.Name
  , lowerState   :: L.LowerState

  , driver       :: D.Driver
  , root         :: FilePath

  , luaState     :: L.State

  , debugMode    :: DebugMode

  , currentFile  :: Maybe FilePath
  , outputHandle :: Handle
  }

defaultState :: DebugMode -> IO ReplState
defaultState mode = do
  state <- L.newstate
  -- Init our default libraries
  L.runWith state L.openlibs

  root <- getCurrentDirectory
  pure ReplState
    { resolveScope = Bi.builtinResolve
    , inferScope   = Bi.builtinEnv
    , emitState    = B.defaultEmitState
    , lastName     = S.TgName (T.pack "a") 1
    , lowerState   = L.defaultState

    , luaState     = state

    , driver       = D.emptyDriver
    , root         = root

    , debugMode    = mode

    , currentFile  = Nothing
    , outputHandle = stdout
    }

type Listener = Maybe ThreadId

runRepl :: Listener -> InputT (StateT ReplState IO) ()
runRepl tid = do
  line <- getInputLine "> "
  case line of
    Nothing -> finish tid
    Just "" -> runRepl tid
    Just (':':cmd) -> do
      lift $ uncurry (execCommand tid) . span (/=' ') $ cmd
      runRepl tid
    Just line -> getInput line False >>= (lift . execString "=stdin" . T.pack) >> runRepl tid

  where
    getInput :: String -> Bool -> InputT (StateT ReplState IO) String
    getInput input empty =
      case runParser "=stdin" (L.pack input) parseRepl' of
        (Nothing, xs) ->
          case last xs of
            UnclosedString{} -> continue
            UnclosedComment{} -> continue
            UnexpectedEnd{} -> continue
            UnexpectedToken (Token TcEOF _ _) _ -> continue
            _ -> pure input
        _ -> pure input
        where continue = do
                line <- getInputLine ". "
                case line of
                  Nothing -> pure input
                  Just "" | empty -> pure input
                  Just line -> getInput (input ++ '\n':line) (line == "")

parseRepl' :: Parser (Either [S.Toplevel S.Parsed] (S.Expr S.Parsed))
parseRepl' = first pure <$> parseRepl

execCommand :: (MonadState ReplState m, MonadIO m) => Listener -> String -> String -> m ()
execCommand tid "quit" _ = finish tid
execCommand tid "q"    _ = finish tid

execCommand _ "l"    arg = loadCommand arg
execCommand _ "load" arg = loadCommand arg

execCommand _ "r"      _ = reloadCommand
execCommand _ "reload" _ = reloadCommand

execCommand _ "t" arg = typeCommand arg
execCommand _ "type" arg = typeCommand arg

execCommand _ "i" arg = infoCommand arg
execCommand _ "info" arg = infoCommand arg

execCommand _ "c" arg = compileCommand arg
execCommand _ "compile" arg = compileCommand arg

execCommand _ "add-library-path" arg = liftIO $
  case dropWhile isSpace arg of
    [] -> putStrLn ":add-library-path needs an argument"
    dir -> do
      path <- canonicalizePath dir
      exists <- doesDirectoryExist path
      if exists
         then do
           existing <- lookupEnv "AMC_LIBRARY_PATH"
           setEnv "AMC_LIBRARY_PATH" (maybe path ((path ++ ":") ++) existing)
         else putStrLn $ arg ++ ": No such directory"

execCommand _ "version" _ = liftIO (putStrLn ("The Amulet compiler, version " ++ $amcVersion))

execCommand _ cmd _ = outputDoc ("Unknown command" <+> verbatim cmd)

-- | Split a string into arguments
parseArgs :: String -> [String]
parseArgs xs =
  let (ys, y) = parseArgs' xs
      parseArgs' "" = ([], Nothing)
      parseArgs' (' ':xs) = (parseArgs xs, Nothing)
      parseArgs' ('\\':x:xs) = Just . (x:) . fromMaybe [] <$> parseArgs' xs
      parseArgs' (x:xs) = Just . (x:) . fromMaybe [] <$> parseArgs' xs
   in maybe ys (:ys) y


loadCommand :: (MonadState ReplState m, MonadIO m) => String -> m ()
loadCommand arg = case parseArgs arg of
                    [file] -> loadFile file
                    _ -> outputDoc "Usage `:load [file]`"

reloadCommand :: (MonadState ReplState m, MonadIO m) => m ()
reloadCommand = do
  file <- gets currentFile
  case file of
    Nothing -> outputDoc "No module to reload"
    Just file -> loadFile file

infoCommand :: (MonadState ReplState m, MonadIO m) => String -> m ()
infoCommand (T.pack . dropWhile isSpace -> input) = do
  state <- get
  let files :: [(String, T.Text)]
      files = [("<input>", input)]
      (parsed, parseMsg) = runParser "<input>" (L.fromStrict input) parseInfoVar
      handle = outputHandle state
  liftIO $ traverse_ (hReport (outputHandle state) files) parseMsg
  case parsed of
    Nothing -> pure ()
    Just var -> do
      let prog :: [S.Toplevel S.Parsed]
          prog = [ S.LetStmt S.Public
                   [ S.Binding (S.Name "_")
                        (S.VarRef (getL var) (annotation var))
                        True (annotation var) ] ]

      resolved <-
          flip evalNameyT (lastName state)
        . runNullImport
        $ resolveProgram (resolveScope state) prog

      case resolved of
        Right (ResolveResult [ S.LetStmt _ [S.Binding _ (S.VarRef name _) _ _] ] _ _) ->
          liftIO . hPutDoc handle . displayType $
            (inferScope state ^. T.names . at name . non undefined)
        _ -> liftIO . hPutDoc handle $ "Name not in scope:" <+> pretty (getL var)


typeCommand :: (MonadState ReplState m, MonadIO m) => String -> m ()
typeCommand (dropWhile isSpace -> input) = do
  state <- get
  let files :: [(String, T.Text)]
      files = [("<input>", T.pack input)]
      (parsed, parseMsg) = runParser "<input>" (L.pack input) parseReplExpr
      handle = outputHandle state
  liftIO $ traverse_ (hReport (outputHandle state) files) parseMsg
  case parsed of
    Nothing -> pure ()
    Just parsed -> do
      let ann = annotation parsed
          prog :: [S.Toplevel S.Parsed]
          prog = [ S.LetStmt S.Public [ S.Matching (S.Wildcard ann) parsed ann ] ]

      (infer, es) <- wrapDriver $ D.inferWith (root state) prog (resolveScope state) (inferScope state)
      hReportAll (outputHandle state) files es
      case infer of
        Nothing -> pure ()
        Just (prog, _, _) ->
          let ~[S.LetStmt _ [ S.TypedMatching _ expr _ _ ]] = prog
              t = S.getType expr
          in liftIO $ hPutDoc handle (string input <+> colon <+> displayType t)

compileCommand :: (MonadState ReplState m, MonadIO m) => FilePath -> m ()
compileCommand [] = liftIO $ putStrLn ":compile command needs an argument"
compileCommand (dropWhile isSpace -> path) = do
  current <- gets currentFile
  output <- gets outputHandle
  files <- D.fileMap =<< gets driver
  case current of
    Just file -> do
      in_p <- liftIO $ canonicalizePath file
      (core, errors) <- wrapDriver (D.compile in_p)
      handle <- liftIO $ openFile path WriteMode

      case core of
        Just core -> do
          optm <- wrapNamey $ optimise core
          (_, lua) <- emitCore optm
          liftIO $ Bs.hPutStr handle lua
        Nothing ->
          hReportAll output files errors
      liftIO $ hClose handle
    Nothing -> liftIO $ putStrLn "No file loaded"

execString :: (MonadState ReplState m, MonadIO m)
           => SourceName -> T.Text
           -> m Bool
execString name line = do
  oldInfer <- gets inferScope

  core <- parseCore parseRepl' name line
  case core of
    Nothing -> pure False
    Just (vs, prog, core) -> do
      (luaExpr, luaSyntax) <- emitCore core
      state <- get
      (ok, res) <- liftIO $ do
        dump (debugMode state) prog core core luaExpr oldInfer (inferScope state)

        L.runWith (luaState state) $ do
          L.OK <- L.dostring "-- time out hook\nlocal function f() error('Timed out!', 3) end; debug.sethook(f, '', 1e6)"
          L.OK <- L.loadbuffer luaSyntax ('=':name)
          res <- L.try $ L.call 0 L.multret

          case res of
            Right () -> do
              vs' <- for vs $ \(v, _) -> do
                let Just (_, vs) = VarMap.lookup v (emitState state ^. B.topVars)
                repr <- traverse (valueRepr . evalExpr . B.unsimple) vs
                let CoVar id _ _ = v
                    var = S.TgName (covarDisplayName v) id
                case inferScope state ^. T.names . at var of
                  Just _ -> pure (Just (pretty v <+> equals </> hsep (map pretty repr)))
                  Nothing -> pure Nothing

              pure (True, catMaybes vs')
            Left (L.Exception msg) -> pure (False, [string msg])

      unless (null res) (outputDoc (vsep res))
      pure ok

evalExpr :: LuaExpr -> L.Lua ()
evalExpr (LuaRef (LuaName n)) = L.getglobal (T.unpack n)
evalExpr LuaNil = L.pushnil
evalExpr LuaTrue = L.pushboolean True
evalExpr LuaFalse = L.pushboolean True
evalExpr (LuaInteger n) = L.pushinteger (fromIntegral n)
evalExpr (LuaNumber n) = L.pushnumber (L.Number n)
evalExpr (LuaString s) = L.pushstring (T.encodeUtf8 s)
evalExpr s = error ("Not a simple expression: " ++ show s)

-- | We convert any top-level local declarations into global ones. This
-- means they are accessible outside normal REPL invocations.
patchupLua :: B.TopEmitState -> LuaStmt -> LuaStmt
patchupLua s (LuaLocal vs [])
  | all (isTopVar s) vs
  = LuaAssign vs [LuaNil]
patchupLua s (LuaLocal vs es)
  | all (isTopVar s) vs
  = LuaAssign vs es
patchupLua s (LuaLocalFun v as ss)
  | isTopVar s v
  = LuaAssign [v] [LuaFunction as ss]
patchupLua _ x = x

isTopVar :: B.TopEmitState -> LuaVar -> Bool
isTopVar s (LuaName v)
  | Just _ <- B.getEscaped v (s ^. B.topEscape) :: Maybe CoVar
  = True
isTopVar _ _ = False

-- | Patchup the usage of a series of statements to ensure every one is
-- considered "used".
--
-- This guarantees we'll generate bindings for them all, and so they can
-- be evaluated in the REPL.
patchupUsage :: IsVar a => [C.AnnStmt b (OccursVar a)] -> [C.AnnStmt b(OccursVar a)]
patchupUsage [] = []
patchupUsage (s@C.Foreign{}:xs) = s:patchupUsage xs
patchupUsage (s@C.Type{}:xs) = s:patchupUsage xs
patchupUsage (C.StmtLet (C.One v):xs) = C.StmtLet (C.One (first3 patchupVarUsage v)):patchupUsage xs
patchupUsage (C.StmtLet (C.Many v):xs) = C.StmtLet (C.Many (map (first3 patchupVarUsage) v)):patchupUsage xs

-- | Patchup the usage of a single variable. See 'patchupUsage' for more
-- information.
patchupVarUsage :: OccursVar a -> OccursVar a
patchupVarUsage (OccursVar v u) = OccursVar v (u <> Once)

parseCore :: (MonadState ReplState m, MonadIO m)
          => Parser (Either [S.Toplevel S.Parsed] (S.Expr S.Parsed))
          -> SourceName -> T.Text
          -> m (Maybe ([(CoVar, C.Type CoVar)]
                      , [S.Toplevel S.Typed]
                      , [Stmt CoVar]))
parseCore parser name input = do
  state <- get
  let files :: [(String, T.Text)]
      files = [(name, input)]
      (parsed, parseMsg) = runParser name (L.fromStrict input) parser
  liftIO $ traverse_ (hReport (outputHandle state) files) parseMsg

  case parsed of
    Nothing -> pure Nothing
    Just parsed -> do
      let parsed' = case parsed of
            Left s -> s
            Right e -> [S.LetStmt S.Public [S.Binding (S.Name "_") e True (annotation e)]]

      (lower, es) <- wrapDriver $ D.lowerWith (root state) parsed'
                       (resolveScope state) (inferScope state) (lowerState state)
      driver_files <- D.fileMap =<< gets driver
      hReportAll (outputHandle state) (files ++ driver_files) es
      case lower of
        Nothing -> pure Nothing
        Just (lower, lState, typed, env, ResolveResult _ _ sig) -> do
          let lastTerms = case lower of
                [] -> []
                _:_ -> case last lower of
                  (C.StmtLet (C.One (v, t, _))) -> [(v, t)]
                  (C.StmtLet (C.Many vs)) -> map (\(v, t, _) -> (v, t)) vs
                  _ -> []

          modify (\s -> s { resolveScope = sig, inferScope = env, lowerState = lState })
          pure $ Just (lastTerms, typed, lower)


emitCore :: MonadState ReplState m => [Stmt CoVar] -> m (LuaStmt, Bs.ByteString)
emitCore core = do
  emit <- gets emitState

  let core' = patchupUsage . snd . tagOccurStmt (const occursSet) OccursVar $ core
      (luaStmt, emit') = uncurry B.addBuiltins $ runState (B.emitStmt core') emit
      luaExpr = LuaDo . map (patchupLua emit') . toList $ luaStmt
      luaSyntax = T.encodeUtf8 . display . uncommentDoc . renderPretty 0.8 100 . pretty $ luaExpr

  modify (\s -> s { emitState = emit' })
  pure (luaExpr, luaSyntax)

-- | Reset the environment and load a series of files from environment
loadFile :: (MonadState ReplState m, MonadIO m) => FilePath -> m ()
loadFile file = do
  -- Reset the state
  dmode <- gets debugMode
  handle <- gets outputHandle
  state' <- liftIO (defaultState dmode)
  put state'

  (prelude_sig, prelude_env, core) <- wrapDriver D.loadPrelude

  modify' (\s -> s { currentFile = Just file
                   , outputHandle = handle
                   , resolveScope = prelude_sig <> resolveScope s
                   , inferScope = prelude_env <> inferScope s })

  (_, luaSyntax) <- emitCore core
  _ <- liftIO $ L.runWith (luaState state') $
    L.dostring luaSyntax

  -- Load each file in turn
  path <- liftIO $ canonicalizePath file
  exists <- liftIO $ doesFileExist path
  if not exists
  then outputDoc ("Cannot open" <+> verbatim file)
  else do
    outputDoc $ "Loading:" <+> verbatim file

    (core, es) <- wrapDriver $ D.compile path

    files <- D.fileMap =<< gets driver
    hReportAll handle files es
    case core of
      Nothing -> pure ()
      Just core -> do
        hReportAll handle files es

        (sig, env, lEnv) <- wrapDriver $ do
          ~(Just sig) <- D.getSignature path
          ~(Just env) <- D.getTypeEnv path
          ~(Just lEnv) <- D.getLowerState path
          pure (sig, env, lEnv)

        modify (\s -> s { resolveScope = resolveScope s <> sig
                        , inferScope = inferScope s <> env
                        , lowerState = lowerState s <> lEnv })

        (luaExpr, luaSyntax) <- emitCore core

        luaState <- gets luaState
        liftIO $ do
          dump dmode [] core core luaExpr Bi.builtinEnv env
          res <- L.runWith luaState $ do
            code <- L.dostring luaSyntax

            case code of
              L.OK -> pure (Right ())
              _ -> do
                val <- valueRepr (pure ())
                L.pop 1
                case val of
                  String str -> pure (Left (text str <+> parens (shown code)))
                  _ -> pure (Left (keyword "Error:" <+> pretty val))

          case res of
            Left err -> hPutDoc handle err
            Right () -> pure ()

outputDoc :: (MonadState ReplState m, MonadIO m) => Doc -> m ()
outputDoc x = do
  h <- gets outputHandle
  liftIO $ do
    hPutDoc h x
    hFlush h

runRemoteReplCommand :: Int -> String -> IO ()
runRemoteReplCommand port command = Net.withSocketsDo $ do
  sock <- Net.socket Net.AF_INET Net.Stream Net.defaultProtocol
  r <- try $ Net.connect sock (Net.SockAddrInet (fromIntegral port) $ Net.tupleToHostAddress (127, 0, 0, 1))
  case r of
    Right () -> do
      handle <- Net.socketToHandle sock ReadWriteMode
      hSetEncoding handle utf8
      T.hPutStrLn handle (T.pack command)
      T.hPutStrLn handle mempty
      T.putStr =<< T.hGetContents handle
    Left (_ :: SomeException) ->
      putStrLn $ "Failed to connect to server on port " ++ show port

loadReplPrelude :: ReplState -> IO ReplState
loadReplPrelude st = flip execStateT st $ do
  dmode <- gets debugMode
  handle <- gets outputHandle
  state' <- liftIO (defaultState dmode)
  put state'
  (prelude_sig, prelude_env, core) <- wrapDriver D.loadPrelude

  modify (\s -> s { currentFile = Nothing
                  , outputHandle = handle
                  , resolveScope = prelude_sig <> resolveScope s
                  , inferScope = prelude_env <> inferScope s
                  })

  (_, luaSyntax) <- emitCore core

  _ <- liftIO $ L.runWith (luaState state') $
    L.dostring luaSyntax

  get

repl :: Int -> DebugMode -> IO ()
repl port mode = replFrom port mode Nothing

replFrom :: Int -> DebugMode -> Maybe FilePath -> IO ()
replFrom port mode file = do
  state <- maybe loadReplPrelude (execStateT . loadFile) file =<< defaultState mode
  hSetBuffering stdout LineBuffering

  ready <- newEmptyMVar
  tid <-
    if port /= 0
       then forkIO $ startServer ready port state
       else do
         putMVar ready ()
         myThreadId

  takeMVar ready
  bracket (pure ()) (const (killThread tid)) $ \() ->
    evalStateT (runInputT defaultSettings (runRepl (Just tid))) state

finish :: MonadIO m => Listener -> m ()
finish Nothing = pure ()
finish (Just i) = liftIO $ throwTo i ThreadKilled

startServer :: MVar () -> Int -> ReplState -> IO ()
startServer ready port state = Net.withSocketsDo $ bracket getSock Net.close (work state) where
  getSock = do
    (addr:_) <-
      Net.getAddrInfo (Just (Net.defaultHints { Net.addrFlags = [ Net.AI_NUMERICHOST
                                                                , Net.AI_PASSIVE
                                                                ]
                                              , Net.addrSocketType = Net.Stream }))
                      (Just "127.0.0.1")
                      (Just (show port))
    sock <- Net.socket Net.AF_INET Net.Stream Net.defaultProtocol
    x <- try $ do
      Net.setSocketOption sock Net.ReuseAddr 1
      Net.bind sock (Net.addrAddress addr)
      Net.listen sock 4
    case x of
      Left (_ :: SomeException) -> do
        putStrLn $ "Failed to start REPL server on port " ++ show port
        killThread =<< myThreadId
      Right () -> pure ()
    putStrLn $ "Listening on port " ++ show port
    putMVar ready ()
    pure sock

  handleReplLine line =
    if | T.null line -> pure ()
       | ':' == T.head line -> uncurry (execCommand Nothing) . span (/=' ') $ T.unpack (T.tail line)
       | otherwise -> () <$ execString "=<remote command>" line

  handleLines handle = do
    eof <- liftIO $ hIsEOF handle
    if eof then
      pure ()
    else do
      line <- liftIO $ T.hGetLine handle
      if T.null line then
        pure ()
      else do
        handleReplLine line
        handleLines handle

  work state sock = do
    (conn, _) <- Net.accept sock
    handle <- Net.socketToHandle conn ReadWriteMode
    hSetEncoding handle utf8

    state <- execStateT (handleLines handle) (state { outputHandle = handle })

    hClose handle

    work state sock

wrapDriver :: MonadState ReplState m
           => StateT D.Driver (NameyT m) a
           -> m a
wrapDriver m = do
  state <- get
  ((res, drive), name)
    <- flip runNameyT (lastName state)
     . flip runStateT (driver state)
     $ m
  put state { lastName = name, driver = drive }
  pure res

wrapNamey :: MonadState ReplState m
          => NameyT m a
          -> m a
wrapNamey m = do
  (res, name) <- runNameyT m =<< gets lastName
  modify (\s -> s { lastName = name })
  pure res
